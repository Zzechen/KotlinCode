package classes

import kotlin.properties.Delegates
import kotlin.properties.ReadOnlyProperty
import kotlin.properties.ReadWriteProperty
import kotlin.reflect.KProperty

/**
 * 属性委托
 * 总是存在一些通用的属性，虽然可以每次需要时手动实现，但一次实现并多次使用是极好的，甚至放在库中
 * 几种实现方式：
 * 1、懒加载属性：会在第一次使用时初始化
 * 2、observable属性：观察者会在属性改变时得到通知
 * 3、将属性存储在map中，而不是将各个属性分隔开来
 */
//对于上述情况，Kotlin支持委托属性：
class Delegated {
    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        return "$thisRef, thank you for delegating '${property.name}' to me!"
    }

    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
        println("$value has been assigned to '${property.name}' in $thisRef.'")
    }
}

/**
 * 完整的写法是：
 * val/var <property name>:<Type> by <expression>
 * 'by'后的表达式就是'delegate'，因为get()/set()方法关联的属性会委托给它的getValue()和setValue()方法。
 * 属性委托不需要实现任何的接口，但是必须提供getValue()（setValue()只是针对'var'属性）方法
 */
class DelegatedExample {
    var p: String by Delegated()
}
//note:1.1之后，可以在代码块，方法体重声明属性委托，而不要求作为类成员

/**
 * 标准委托
 * Kotlin标准库提供了一些有用的委托工厂方法
 */
/**
 * 懒加载 -- Lazy
 * lazy()使用lambda表达式，返回Lazy<T>对象来委托实现懒加载属性：
 * 第一次使用get()方法时执行lambda表达式并且记录结果，后续调用get()方法时，只是返回结果即可
 */
val lazyValue: String by lazy(LazyThreadSafetyMode.NONE) {
    println("computed!")
    "Hello"
}

/**
 * 默认情况下，懒加载属性是同步的：
 * LazyThreadSafetyMode.PUBLICATION --- 允许多线程并发调用lazy方法，但是只会接收第一个返回的结果
 * LazyThreadSafetyMode.NONE --- 无视线程（建议在确定只有一个线程使用时），结果不确定
 */

/**
 * Observable
 * Deletages.observable()方法包含两个参数：初始值和定义执行者。handler会在每次为属性赋值时获得通知（行为会在已赋值完成）。
 * handler有三个参数：被赋值的属性，老的值，新值
 */
//如果想阻止赋值行为，可以使用vetoable()方法，改方法是在赋值前回调
class Student {
    var name: String by Delegates.observable("Haha") { property, oldValue, newValue ->
        println("$oldValue --> $newValue")
    }
    var age: Int by Delegates.vetoable(1) { property, oldValue, newValue ->
        println("new age is $newValue,old age is $oldValue")
        10 != newValue
    }
}

/**
 * 存储在Map中
 * 通常是在解析JSON或者是其他"动态"的事情
 * 这种情况下，可以使用map自己内部属性的委托
 */
//note:在不存在对应的key时，会抛出NoSuchElementException
class DelegateUser(val map: Map<String, Any?>) {
    val name: String by map
    val age: Int by map
}

//如果使用MutableMap时，可以作用'var'属性
class DelegateMutableUser(val map: MutableMap<String, Any?>) {
    var name: String by map
    var age: Int by map
}

/**
 * 局部属性委托
 * 自1.1之后
 */
//fun example(computeFoo: () -> Foo) {
//    val memoizedFoo by lazy(computeFoo)
//    if (memoizedFoo.isValid()) {
//
//    }
//}

/**
 * 属性委托要求
 */
/**
 * 对于只读属性（'val'），委托必须提供getValue方法，并且包含如下参数
 * 1、thiRef -- 必须是与属性的拥有者相同或者为其子类（对于扩展属性 - 类型也会扩展）
 * 2、property -- 必须是KProperty<*>或者其子类
 * 改方法的返回值必须是对应属性的类型或者是子类型
 */
/**
 * 对于可变属性（'var'），需要增加额外的setValue方法，具有如下参数
 * 1、thisRef -- 和getValue中的相同
 * 2、property -- 和getValue中的相同
 * 3、new value -- 必须是相应属性的类型或是子类型
 */
//getValue和setValue方法可以提供给成员方法或者是扩展方法，每个方法需要提供'operator'修饰，
//可以直接继承Kotlin中标准库中ReadOnlyProperty或者ReadWriteProperty类，实现类中的方法即可
class DelegateRead : ReadOnlyProperty<Student, String> {
    override fun getValue(thisRef: Student, property: KProperty<*>): String = property.toString()
}

class DelegateWrite : ReadWriteProperty<Student, String> {
    override fun getValue(thisRef: Student, property: KProperty<*>): String = property.toString()

    override fun setValue(thisRef: Student, property: KProperty<*>, value: String) {
        println("$value has been assigned to '${property.name}' in $thisRef.'")
    }
}

/**
 * Translation Rules
 * 对于每个委托的属性，Kotlin编译器生成而外的属性，并且委托是通过这个属性。比如原有属性'prop'的隐藏属性为'prop$delegate',
 * 并且委托通过这个属性实现
 */
//class C {
//    var prop: Type by MyDelegate()
//}
//this code is generated by the compiler instead:
//class C {
//    private val prop$delegate = MyDelegate()
//    var prop: Type
//        get() = prop$delegate.getValue(this, this::prop)
//    set(value: Type) = prop$delegate.setValue(this, this::prop, value)
//}


fun main(args: Array<String>) {
    //当使用DelegatedExample中的p属性时，会调用Deleate中的getValue方法，第一个参数是持有属性的对象，第二个参数是属性自己
    val p = DelegatedExample()
    println(p.p)
    //当为p赋值时，setValue方法会调用
    p.p = "new"

    //虽然调用两次，当只在第一次执行时调用lazy方法，后续只是使用结果
    println(lazyValue)
    println(lazyValue)

    //observable方式
    var stu = Student()
    println(stu.name)
    stu.name = "Tom"
    stu.age = 10
    println(stu.age)

    //map
    val user = DelegateUser(mapOf(
            "name" to "John Doe",
            "age" to 25
    ))
    //通过map中的key值，可以通过user直接获取
    println(user.name)
    println(user.age)
}